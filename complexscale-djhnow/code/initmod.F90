#include "definitions.INC"

MODULE INITMOD
USE MPI
USE STRUCTS
USE TOOTH
USE HAMMOD
USE QUAD
IMPLICIT NONE

CONTAINS

! ------------------------------------------------------------------------------------------

SUBROUTINE INIT_PARAMETERS(PARAMS,N,NSMALL,TFACTOR,NCOR,NELEC, &
  DELTA,THETA,VQUAD,NUC_ON_GRID)

INTEGER, INTENT(IN) :: N,NSMALL,NCOR,NELEC,TFACTOR
REAL *8, INTENT(IN) :: DELTA, THETA
LOGICAL, INTENT(IN) :: VQUAD, NUC_ON_GRID
TYPE(PARAMETERS), INTENT(OUT) :: PARAMS

PARAMS % VQUAD = VQUAD
PARAMS % N = N
PARAMS % NSMALL = NSMALL
PARAMS % TFACTOR = TFACTOR
PARAMS % NCOR = NCOR
PARAMS % NELEC = NELEC
PARAMS % DELTA = DELTA
PARAMS % THETA = THETA
PARAMS % NN = 2*N+1

!! variable nbig in this program is different from nbig in jrj, djh notes.
!!   here is used to allocate tinv, not solve for it.
!! good enough if we are only putting 
!! nuclei on grid points, as we are for helium doublyexcited.
!!  -djh

PARAMS % NBIG = 2*N+1

PARAMS % M = (2*N+1)**3
PARAMS % PI = 4D0*ATAN(1D0)
PARAMS % NUC_ON_GRID = NUC_ON_GRID

#if ISREAL
   PARAMS % SCALE = 1D0
#else
   PARAMS % SCALE = DCMPLX(COS(THETA),SIN(THETA))
#endif

END SUBROUTINE INIT_PARAMETERS

! ------------------------------------------------------------------------------------------

SUBROUTINE INIT_MPI_DATA(MPIDATA,PARAMS,ME,NP)

INTEGER, INTENT(IN) :: ME, NP
TYPE(PARAMETERS), INTENT(INOUT) :: PARAMS
TYPE(MPI_DATA), INTENT(OUT) :: MPIDATA
INTEGER :: K,M,NELEC

! M = (2*N+1)**3 = TOTAL NUMBER OF 3D GRID POINTS
! ME = PROCESS RANK
! NP = NUMBER OF PROCESSES
! COMM = MPI COMMUNICATOR (MPI_COMM_WORLD)
! MPISIZE = SIZE OF (NUMBER) DATATYPE
! MBLK = M / NP 
! MM = LOCAL VECTOR SIZE 
!      IF NELEC = 1, MM = MBLK
!      IF NELEC = 2, MM = M*MBLK
!      IF NELEC = 3, MM = M*M*MBLK

M = PARAMS % M
NELEC = PARAMS % NELEC
MPIDATA % COMM_TIME = 0
MPIDATA % ME = ME
MPIDATA % NP = NP
MPIDATA % COMM = MPI_COMM_WORLD

#if ISREAL == 1
   MPIDATA % MPISIZE = MPI_DOUBLE_PRECISION
#else
   MPIDATA % MPISIZE = MPI_DOUBLE_COMPLEX
#endif

MPIDATA % MAXBLOCK = M/NP + MOD(M,NP)

IF(ME == 0) THEN
   MPIDATA % MBLK = MPIDATA % MAXBLOCK
   MPIDATA % FIRST = 1
   MPIDATA % LAST = MPIDATA % MAXBLOCK
ELSE
   MPIDATA % MBLK = M/NP
   MPIDATA % FIRST = MPIDATA % MAXBLOCK + (ME-1) * MPIDATA%MBLK + 1
   MPIDATA % LAST = MPIDATA % MAXBLOCK + ME * MPIDATA%MBLK
END IF

MPIDATA % MM = MPIDATA % MBLK*M**(NELEC-1)

ALLOCATE(MPIDATA % BLOCKS(NP),MPIDATA % DISPLS(NP))
ALLOCATE(MPIDATA % LOW(NP),MPIDATA % HIGH(NP))

MPIDATA % BLOCKS = M/NP
MPIDATA % BLOCKS(1) = MPIDATA % MAXBLOCK

DO K = 1,NP
   MPIDATA % LOW(K) = 1 + SUM(MPIDATA % BLOCKS(1:K-1))
   MPIDATA % HIGH(K) = SUM(MPIDATA % BLOCKS(1:K))
END DO

MPIDATA % DISPLS = 0
DO K = 2,NP
   MPIDATA % DISPLS(K) = MPIDATA % DISPLS(K-1) + MPIDATA % BLOCKS(K-1)
END DO

END SUBROUTINE INIT_MPI_DATA

! ------------------------------------------------------------------------------------------

SUBROUTINE INIT_MOLECULE(MOL,NUCLEI) !!MOL,NUCLEI,NELEC,DELTA)

INTEGER, INTENT(IN) :: NUCLEI
!REAL *8, INTENT(INOUT) :: DELTA
!INTEGER, INTENT(INOUT) :: NELEC
TYPE(MOLECULE), INTENT(OUT) :: MOL

MOL % NUCLEI = NUCLEI
ALLOCATE(MOL % CHARGE(NUCLEI))
ALLOCATE(MOL % RNUC(3,NUCLEI))

END SUBROUTINE INIT_MOLECULE

! ------------------------------------------------------------------------------------------

SUBROUTINE INIT_CONTOUR(GAMMA,A,B,THETA,P,N,DELTA)

INTEGER, INTENT(IN) :: N
REAL *8, INTENT(IN) :: A, B, THETA, P, DELTA
TYPE(CONTOUR), INTENT(OUT) :: GAMMA
INTEGER :: J
REAL *8 :: R,X,Y,DX,DY
COMPLEX *16 :: Z(-N:N), JACB(-N:N)

GAMMA % N = N
GAMMA % NN = 2*N+1

! TRANSFORMATION
DO J = 0,N
   R = J*DELTA
   X = A*R + B*COS(THETA)*R**P
   Y = B*SIN(THETA)*R**P
   Z(J) = DCMPLX(X,Y)
   DX =  A + B*COS(THETA)*P*R**(P-1)
   DY = B*SIN(THETA)*P*R**(P-1)
   JACB(J) = DCMPLX(DX,DY)
END DO

! ODD EXTENSION
DO J = 1,N
  Z(-J) = -Z(J)
  JACB(-J) = CONJG(JACB(J))
END DO

ALLOCATE(GAMMA % Z(GAMMA%NN))
ALLOCATE(GAMMA % JACB(GAMMA%NN))

GAMMA % Z = Z
GAMMA % JACB = JACB

END SUBROUTINE INIT_CONTOUR

! ------------------------------------------------------------------------------------------

SUBROUTINE INIT_HAMILTONIAN(HAM,PARAMS,MOL,MPIDATA)

TYPE(PARAMETERS), INTENT(IN) :: PARAMS
TYPE(MPI_DATA), INTENT(IN) :: MPIDATA
TYPE(MOLECULE), INTENT(IN) :: MOL
TYPE(HAMILTONIAN), INTENT(OUT) :: HAM
INTEGER :: N,NN,M,MM,NBIG,MBLK,I1,I2,ME,NELEC,FIRST,LAST,I,J,K
REAL *8 :: DELTA, FAC, XX, YY, ZZ
REAL *8, ALLOCATABLE :: U(:,:,:)

ME = MPIDATA % ME
NELEC = PARAMS % NELEC
N = PARAMS % N
NN = PARAMS % NN
M = PARAMS % M
MM = MPIDATA % MM
NBIG = PARAMS % NBIG
MBLK = MPIDATA % MBLK
DELTA = PARAMS % DELTA
FIRST = MPIDATA % FIRST
LAST = MPIDATA % LAST

IF(ME == 0) WRITE(*,"(A)") "COMPUTING PRIMITIVE HAMILTONIAN..."

HAM % MOL = MOL

IF(ALLOCATED(HAM % T)) DEALLOCATE(HAM % T)
IF(ALLOCATED(HAM % V)) DEALLOCATE(HAM % V)
IF(ALLOCATED(HAM % TINV)) DEALLOCATE(HAM % TINV)

ALLOCATE(HAM % T(NN,NN))
ALLOCATE(HAM % TINV(-NBIG:NBIG,-NBIG:NBIG,-NBIG:NBIG))

CALL KEMATRIX(HAM % T,NN,DELTA)
HAM % T = HAM % T / PARAMS % SCALE**2

CALL GETINVERSE(HAM % TINV,NBIG,PARAMS%NSMALL * PARAMS%TFACTOR,PARAMS%NSMALL,DELTA)

IF(PARAMS % NUC_ON_GRID) THEN

   ALLOCATE(HAM % V(MM))

   IF(PARAMS % NELEC == 1) THEN
      CALL POTENTIAL1(HAM,PARAMS,MOL,MPIDATA)
   ELSE IF(PARAMS % NELEC == 2) THEN
      CALL POTENTIAL2(HAM,PARAMS,MOL,MPIDATA)
   ELSE IF(PARAMS % NELEC == 3) THEN
      CALL POTENTIAL3(HAM,PARAMS,MOL,MPIDATA)
   END IF

   HAM % V = HAM % V / PARAMS % SCALE

END IF

END SUBROUTINE INIT_HAMILTONIAN

! ------------------------------------------------------------------------------------------

SUBROUTINE INIT_LANPARAMS(LP,NUMEIGS,KDIM,CHECK,TOL,MM,GSORTH,SAVE_VECTORS)

INTEGER, INTENT(IN) :: NUMEIGS, KDIM, CHECK, MM
REAL *8, INTENT(IN) :: TOL
LOGICAL, INTENT(IN) :: GSORTH, SAVE_VECTORS

TYPE(LANPARAMS), INTENT(OUT) :: LP

LP % NUMEIGS = NUMEIGS
LP % KDIM = KDIM
LP % CHECK = CHECK
LP % TOL = TOL
LP % GSORTH = GSORTH
LP % SAVE_VECTORS = SAVE_VECTORS

IF(ALLOCATED(LP % EIGENVALUES)) DEALLOCATE(LP % EIGENVALUES)
IF(ALLOCATED(LP % EIGENVECTORS)) DEALLOCATE(LP % EIGENVECTORS)
IF(ALLOCATED(LP % RESIDUAL)) DEALLOCATE(LP % RESIDUAL)
ALLOCATE(LP % EIGENVALUES(NUMEIGS))
ALLOCATE(LP % RESIDUAL(NUMEIGS))
IF(SAVE_VECTORS) ALLOCATE(LP % EIGENVECTORS(MM,NUMEIGS))

END SUBROUTINE INIT_LANPARAMS

! ------------------------------------------------------------------------------------------

END MODULE INITMOD
